import cv2
import numpy as np
import matplotlib.pyplot as plt
import os
from datetime import datetime

def create_test_images():
    """Create example images for testing if they don't exist"""
    if not os.path.exists("qc_test_images"):
        os.makedirs("qc_test_images")

    # Create reference image (good product)
    reference = np.ones((300, 400), dtype=np.uint8) * 200  # Light gray background
    cv2.rectangle(reference, (100, 100), (300, 200), 150, -1)
    cv2.circle(reference, (200, 150), 40, 180, -1)
    cv2.imwrite("qc_test_images/reference_good.jpg", reference)

    # Test image 1: with scratch
    test1 = reference.copy()
    cv2.line(test1, (150, 120), (250, 180), 100, 3)
    cv2.imwrite("qc_test_images/test_with_scratch.jpg", test1)

    # Test image 2: with spot
    test2 = reference.copy()
    cv2.circle(test2, (280, 130), 15, 100, -1)
    cv2.imwrite("qc_test_images/test_with_spot.jpg", test2)

    # Test image 3: good image
    cv2.imwrite("qc_test_images/test_good.jpg", reference)

    print("Created test images in folder 'qc_test_images'")
    return ["reference_good.jpg", "test_with_scratch.jpg", "test_with_spot.jpg", "test_good.jpg"]

class SimpleQCVision:
    def _init_(self, reference_image_path=None):
        if reference_image_path and os.path.exists(reference_image_path):
            self.reference_image = cv2.imread(reference_image_path, cv2.IMREAD_GRAYSCALE)
            print(f"Reference image loaded: {reference_image_path}")
        else:
            self.reference_image = None
            print("No reference image provided. Using anomaly detection mode.")
        
        self.threshold = 30
        self.min_defect_size = 50

    def detect_defects(self, image_path):
        test_image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        if test_image is None:
            print(f"Error: Could not load image {image_path}")
            return None, []

        vis_image = cv2.cvtColor(test_image, cv2.COLOR_GRAY2BGR)
        test_image_blur = cv2.GaussianBlur(test_image, (5, 5), 0)

        if self.reference_image is not None:
            defects = self._detect_with_reference(test_image_blur, vis_image)
        else:
            defects = self._detect_without_reference(test_image_blur, vis_image)

        return vis_image, defects

    def _detect_with_reference(self, test_image, vis_image):
        ref_image = cv2.resize(self.reference_image, (test_image.shape[1], test_image.shape[0]))
        ref_image = cv2.GaussianBlur(ref_image, (5, 5), 0)

        diff = cv2.absdiff(ref_image, test_image)
        _, thresh = cv2.threshold(diff, self.threshold, 255, cv2.THRESH_BINARY)
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        defects = []
        for i, contour in enumerate(contours):
            area = cv2.contourArea(contour)
            if area >= self.min_defect_size:
                x, y, w, h = cv2.boundingRect(contour)
                defect_type = self._classify_defect(test_image, x, y, w, h, area)
                defects.append({
                    "id": i + 1,
                    "type": defect_type,
                    "area": area,
                    "position": (x + w // 2, y + h // 2)
                })
                cv2.rectangle(vis_image, (x, y), (x + w, y + h), (0, 0, 255), 2)
                cv2.putText(vis_image, defect_type, (x, y - 5),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)

        cv2.putText(vis_image, f"Defects: {len(defects)}", (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)

        return defects

    def _detect_without_reference(self, test_image, vis_image):
        thresh = cv2.adaptiveThreshold(test_image, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                       cv2.THRESH_BINARY_INV, 11, 2)
        contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        defects = []
        for i, contour in enumerate(contours):
            area = cv2.contourArea(contour)
            if area >= self.min_defect_size:
                x, y, w, h = cv2.boundingRect(contour)
                defect_type = self._classify_defect(test_image, x, y, w, h, area)
                defects.append({
                    "id": i + 1,
                    "type": defect_type,
                    "area": area,
                    "position": (x + w // 2, y + h // 2)
                })
                cv2.rectangle(vis_image, (x, y), (x + w, y + h), (0, 0, 255), 2)
                cv2.putText(vis_image, defect_type, (x, y - 5),
                            cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)

        cv2.putText(vis_image, f"Defects: {len(defects)}", (10, 30),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)

        return defects

    def _classify_defect(self, image, x, y, w, h, area):
        roi = image[y:y + h, x:x + w]
        if roi.size == 0:
            return "Unknown"

        aspect_ratio = w / h if h > 0 else 0
        mean_intensity = np.mean(roi)

        if aspect_ratio > 3:
            return "Scratch"
        elif area < 200:
            return "Spot"
        elif mean_intensity < 100:
            return "Dark Area"
        elif mean_intensity > 200:
            return "Light Area"
        else:
            return "Surface Defect"

def save_results(vis_image, defects, original_image_name):
    if not os.path.exists("qc_results"):
        os.makedirs("qc_results")

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    base_name = os.path.splitext(original_image_name)[0]
    output_path = f"qc_results/{base_name}_{timestamp}.jpg"
    cv2.imwrite(output_path, vis_image)

    text_path = f"qc_results/{base_name}_{timestamp}_defects.txt"
    with open(text_path, 'w') as f:
        f.write(f"Defect Analysis for {original_image_name}\n")
        f.write(f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Total defects found: {len(defects)}\n\n")
        for defect in defects:
            f.write(f"Defect #{defect['id']}\n")
            f.write(f"  Type: {defect['type']}\n")
            f.write(f"  Area: {defect['area']} pixels\n")
            f.write(f"  Position: {defect['position']}\n\n")

    return output_path

def run_qc():
    print("Starting Manufacturing Quality Control Vision System...")
    print("=" * 50)

    if not os.path.exists("qc_test_images") or len(os.listdir("qc_test_images")) == 0:
        print("Creating test images...")
        image_files = create_test_images()
    else:
        image_files = [f for f in os.listdir("qc_test_images")
                       if f.lower().endswith(('.jpg', '.jpeg', '.png'))]

    if not image_files:
        print("No images found. Please add images to 'qc_test_images' folder.")
        return

    reference_path = os.path.join("qc_test_images", image_files[0])
    qc_system = SimpleQCVision(reference_path)

    for image_file in image_files[1:]:
        image_path = os.path.join("qc_test_images", image_file)
        print(f"\nProcessing: {image_file}")

        vis_image, defects = qc_system.detect_defects(image_path)

        if vis_image is not None:
            print(f"Found {len(defects)} defects:")
            for defect in defects:
                print(f"  Defect #{defect['id']}: {defect['type']}, Area: {defect['area']}")

            output_path = save_results(vis_image, defects, image_file)
            print(f"Results saved to {output_path}")

            plt.figure(figsize=(10, 8))
            plt.imshow(cv2.cvtColor(vis_image, cv2.COLOR_BGR2RGB))
            plt.title(f"Defect Analysis: {image_file}")
            plt.axis('off')
            plt.tight_layout()
            plt.show()

    print("\nQuality control inspection complete!")

if _name_ == "_main_":
    run_qc()
